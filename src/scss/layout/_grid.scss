@mixin grid($key){
  @include check-arg-type($key, 'map');

  $layout: map-get($key, 'layout');
  $child: if(map-get($key, 'child'), map-get($key, 'child'), 'div');
  $gutter: if(map-get($key, 'gutter'), map-get($key, 'gutter'), map-get($ro-layout, 'gutter'));
  $direction: if(map-get($key, 'direction'), map-get($key, 'direction'), 'LTR');
  $global-breakpoints: map-get($key, 'breakpoints');
  $local-breakpoints: false;
  $condition: if(map-get($key, 'condition'), map-get($key, 'condition'), 'min');
  $media-type: map-get($key, 'media-type');
  $keep: map-get($key, 'keep');

  // strip unit when gutter == 0
  $gutter: check-zero-value($gutter);
  $float: if($direction == 'LTR', left, right);

  // has breakpoints
  @if grid-has-breakpoints($layout) {
    
    // update breakpoints
    @if $global-breakpoints { $layout: map-update-breakpoints($layout, $global-breakpoints); }
    $local-breakpoints: map-keys($layout);

    @if index($local-breakpoints, null) != null or index($local-breakpoints, 'default') != null { 
      $keep: false; 
    }

    // divide rows within each breakpoints
    @each $bp in $local-breakpoints {
      @if $bp == 'default' {
        @include grid-base($child, $float, $gutter);
        $keep: true;

        @include divide-rows(map-get($layout, $bp), $gutter, $child, $float);
      } @else {
        @include bp($condition $media-type $bp) {
          @if not $keep {
            @include grid-base($child, $float, $gutter);
            $keep: true;
          }

          @include divide-rows(map-get($layout, $bp), $gutter, $child, $float);
        }
      }
    }

  // no breakpoints
  } @else {
    @include grid-base($child, $float, $gutter);
    @include divide-rows($layout, $gutter, $child, $float);
  }
}

//  width: %
//  direction: float
//  order: margin/float, -100% margin/opposite-float

//  2-1. percentage gutter
//     gutter: no set

//  2-2. gutter with other units
//     gutter: minus margin of the container element, padding of child elements

@mixin grid-base($child, $float, $gutter){
  // default 100% width
  > #{$child} { width: 100%; }

  @include clearfix();
  // gutter: px | em | rem | vw
  @if $gutter != 0 and unit($gutter) != '%' { margin-#{opposite($float)}: - $gutter; }

  > #{$child} {
    float: $float;
    clear: both; // default: single column
    margin-#{opposite($float)}: -100%; // each column is isolated with each other

    // gutter: px | em | rem | vw
    @if $gutter != 0 and unit($gutter) != '%' {
      padding-#{opposite($float)}: $gutter;
      @include box-sizing(border-box);
    }
  }
}

// == divide-rows ==
@mixin divide-rows($value, $gutter, $child, $float) {
  $columns: false;
  $orders: false;
  $list-length: 0;
  $max-order: false;
  
  // reset clear
  > #{$child}:nth-child(n) { clear: none; };

  // many rows
  @if is-nested-list($value) {

    // make grid in each row
    @each $item in $value {
      $columns: grid-get-columns($item);
      $orders: grid-get-orders($item);

      @include grid-row($columns, $orders, $child, $float, $gutter, $max-order, $list-length);

      // get list-length
      @if $columns { 
        $list-length: ($list-length + length($columns)); 
        // clear float on the first column of a new row
        > #{$child}:nth-child(#{$list-length + 1}) { clear: both; }
      }

      // get max-order
      @if $orders {
        @if $max-order {
          $max-order: ($max-order + max($orders...));
        } @else {
          $max-order: max($orders...);
        }
      }
    }

  // single row
  } @else {
    $columns: grid-get-columns($value);
    $orders: grid-get-orders($value);

    @include grid-row($columns, $orders, $child, $float, $gutter);
  }
}

// == grid-row ==
@mixin grid-row($cols, $orders, $child, $float, $gutter, $max-order:false, $list-length:0) {

  $full-col: 0;
  @each $item in $cols {
    $full-col: ($full-col + $item);
  }

  @for $i from 1 through length($cols) {
    // no-flexbox
    $new-orders: ();
    $location: 1;
    @if $orders {
      $new-orders: get-position-from-order($orders);
      $location: index($new-orders, $i);
    } @else {
      $new-orders: (1 2 3 4 5 6 7 8 9 10);
      $location: $i;
    }


    > #{$child}:nth-child(#{$i + $list-length}) {
      @if unit($gutter) == '%' or $gutter == 0 {
        width: ((100% + $gutter) * nth($cols, $i) / $full-col - $gutter);
      } @else {
        width: percentage(nth($cols, $i) / $full-col);
      }

      @if $location == 1 {
        margin-#{$float}: 0;
      } @else {
        $val: 0;
        @for $j from 1 to $location {
          $val: ($val + nth($cols, nth($new-orders, $j)));
        }

        @if unit($gutter) == '%' or $gutter == 0 {
          margin-#{$float}: ((100% + $gutter) * $val / $full-col);
        } @else {
          margin-#{$float}: percentage($val / $full-col);
        }
      }
    }
  }
}

// == grid-get-columns ==
@function grid-has-breakpoints($layout) {
  @if type-of($layout) == 'map' {
    $bools: ();

    @each $bp in map-keys($layout) {
      $type: type-of($bp);
      @if $type == 'string' or $type == 'number' and not unitless($bp) {
        $bools: append($bools, true);
      } @else {
        $bools: append($bools, false);
      }
    }

    @return index($bools, false) == null;
  } @else {
    @return false;
  }
}

@function grid-get-columns($value) {
  $columns: false;

  @if type-of($value) == 'list' or type-of($value) == 'number' {
    $columns: $value;
  } @else if type-of($value) == 'map' {
    @if length(map-keys($value)) == 1 {
      $columns: nth(map-keys($value), 1);
    } @else {
      $columns: map-keys($value);
    }
  }

  @return $columns;
}

// == grid-get-orders ==
@function grid-get-orders($value) {
  $orders: false;
  @if type-of($value) == 'map' {
    @if length(map-values($value)) == 1 {
      $orders: nth(map-values($value), 1);
    } @else {
      $orders: map-values($value);
    }
  }

  @if $orders {
    $min-order: min($orders...);
    $new-orders: ();

    @if $min-order <= 0 {
      @each $item in $orders {
        $new-orders: append($new-orders, ($item + abs($min-order) + 1));
      }

      $orders: $new-orders;
    }
  }

  @return $orders;
}