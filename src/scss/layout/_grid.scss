@mixin grid($key:false){
  $map: false;
  $child: args-get-next($key, 'child', 'div');
  $gutter: args-get-next($key, 'gutter', map-get($ro-layout, 'gutter'));
  $float: if(args-get($key, $ro-text-direction, 'LTR') == 'LTR', left, right);

  $global-bps: args-get-next($key, 'bp');
  $bps: false;
  $condition: args-get($key, ('min' 'max'), 'min');
  $media-type: args-get($key, $ro-media-type);

  $keep: args-get($key, 'keep', false);

  @if type-of($child) == 'list' {
    @error 'Only one type of child element is acceptable. Now is (#{$child}).';
  } @else if type-of($child) != 'string' {
    @error 'Child should be a string. Now is "#{$child}".';
  }

  // get map
  @if type-of($key) == map {
    $map: $key;
  } @else if type-of($key) == 'list' {
    @if is-number-map-list($key) {
      $map: $key;
    } @else {
      @each $item in $key {
        @if type-of($item) == 'map' {
          @if not $map {
            $map: $item;
          } @else {
            $global-bps: $item;
          }
        } @else if not $map and
            type-of($item) == 'list' and is-number-map-list($item) {
          $map: $item;
        }
      }
    }
  }

  // *** output *** //
  // basis
  @if not $keep {
    // use flexbox
    @include ro-flexbox; 
    @include ro-flex-wrap(wrap);
    @include ro-justify-content(space-between);
    @if $float == right {
      @include ro-flex-direction(row-reverse);
    }

    // gutter: 2%
    @if unit($gutter) == % or $gutter == 0 {
      
      // use float
      .lt-ie10 & {
        @include clearfix();
        > #{$child} {
          float: $float;
          width: 100%;
          margin-#{opposite($float)}: $gutter;
        }
      }

    // gutter: 20px | 1em | 1rem
    } @else {

      // use float
      .lt-ie10 & {
        @include clearfix();
        margin-#{opposite($float)}: - $gutter;
        > #{$child} {
          float: $float;
          width: 100%;
          margin-#{opposite($float)}: -100%;
          padding-#{opposite($float)}: $gutter;
          box-sizing: border-box;
        }
      }
    }

  }

  @if $map {
    // has breakpoints
    // ('default': (1 1 1), 800px: (3 4) 1)
    @if grid-has-breakpoints($map) {
      
      .lt-ie10 & > #{$child} { clear: both; }
      // update breakpoints
      @if $global-bps {
        $map: map-update-breakpoints($map, $global-bps);
      }
      $bps: map-keys($map);

      @each $bp in $bps {

        @if $bp == 'default' {
          @include check-list(map-get($map, $bp), $gutter, $child, $float);
        } @else {
          @include bp($condition $media-type $bp) {
            // reset order, clear
            > #{$child}:nth-child(n) { @include ro-order(0); }
            .lt-ie10 & > #{$child} { clear: none; }
            @include check-list(map-get($map, $bp), $gutter, $child, $float);
          }
        }
      }

    // without breakpoints
    // (3 4 5: 1 0 2) (4 6)
    } @else {
      @include check-list($map, $gutter, $child, $float);
    }
  }
}

// == check-list ==
@mixin check-list($value, $gutter, $child, $float) {
  $columns: false;
  $orders: false;
  $has-orders: false;

  $list-length: 0;
  $max-order: 0;
  
  @if is-nested-list($value) {
    @each $item in $value {
      $columns: grid-get-columns($item);
      $orders: grid-get-orders($item);

      @include make-grid($columns, $orders, $child, $float, $gutter, $max-order, $list-length, $has-orders);

      @if $orders { $has-orders: true; }
      @if $columns { $list-length: ($list-length + length($columns)); }
      @if $orders {
        $max-order: ($max-order + max($orders...));
      } @else {
        $max-order: $max-order + 1;
      }
    }

    // some of previous groups have orders, this group doesn't
    %same-order { @include ro-order($max-order); }

  } @else {
    $columns: grid-get-columns($value);
    $orders: grid-get-orders($value);

    @include make-grid($columns, $orders, $child, $float, $gutter);
  }
}

// == make-grid ==
@mixin make-grid($cols, $orders, $child, $float, $gutter, $max-order:0, $list-length:0, $has-orders:false) {

  $full-col: 0;
  @each $item in $cols {
    $full-col: ($full-col + $item);
  }

  // new row: clear float
  .lt-ie10 & > #{$child}:nth-child(n) { clear: none; };
  @if $list-length > 0 {
    .lt-ie10 & > #{$child}:nth-child(#{$list-length + 1}) { clear: both; }
  }

  @for $i from 1 through length($cols) {
    // no-flexbox
    $new-orders: ();
    $location: 1;
    @if $orders {
      $new-orders: get-position-from-order($orders);
      $location: index($new-orders, $i);
    } @else {
      $new-orders: (1 2 3 4 5 6 7 8 9 10);
      $location: $i;
    }

    @if unit($gutter) == % or $gutter == 0 {
      .lt-ie10 & > #{$child}:nth-child(n) { margin-right: $gutter; }
    }

    > #{$child}:nth-child(#{$i + $list-length}) {
      // gutter: 2%
      @if unit($gutter) == % or $gutter == 0 {
        width: ((100% + $gutter) * nth($cols, $i) / $full-col - $gutter);

        // flexbox
        @if $orders { 
          @include ro-order((nth($orders, $i) + $max-order)); 
        } @else if $has-orders {
          @extend %same-order;
        }

        @if $i == length($cols) {
          .lt-ie10 & { margin-right: 0; }
        }

      // gutter: 20px | 1em | 1rem
      } @else {
        width: percentage(nth($cols, $i) / $full-col);
        // 1. Add calc support for chrome back to 19+.
        // 2. No need to add -moz- because firefox already support css-calc form 28+ while it full supports flexbox.
        width: -webkit-calc((100% + #{$gutter}) * #{nth($cols, $i)} / #{$full-col} - #{$gutter});
        width: calc((100% + #{$gutter}) * #{nth($cols, $i)} / #{$full-col} - #{$gutter});

        // flexbox
        @if $orders { 
          @include ro-order((nth($orders, $i) + $max-order)); 
        } @else if $has-orders {
          @extend %same-order;
        }

        .lt-ie10 & {
          // reset width from calc value for IE9
          width: percentage(nth($cols, $i) / $full-col);
          @if $location == 1 {
            margin-#{$float}: 0;
          } @else {
            $val: 0;
            @for $j from 1 to $location {
              $val: ($val + nth($cols, nth($new-orders, $j)));
            }
            margin-#{$float}: percentage($val / $full-col);
          }
        }
      }
    }
  }
}

// == grid-get-columns ==
@function grid-has-breakpoints($map) {
  @if type-of($map) == 'map' {
    $bools: ();

    @each $bp in map-keys($map) {
      $type: type-of($bp);
      @if $type == 'string' or $type == 'number' and not unitless($bp) {
        $bools: append($bools, true);
      } @else {
        $bools: append($bools, false);
      }
    }

    @return index($bools, false) == null;
  } @else {
    @return false;
  }
}

@function grid-get-columns($value) {
  $columns: false;

  @if type-of($value) == 'list' or type-of($value) == 'number' {
    $columns: $value;
  } @else if type-of($value) == 'map' {
    @if length(map-keys($value)) == 1 {
      $columns: nth(map-keys($value), 1);
    } @else {
      $columns: map-keys($value);
    }
  }

  @return $columns;
}

// == grid-get-orders ==
@function grid-get-orders($value) {
  $orders: false;
  @if type-of($value) == 'map' {
    @if length(map-values($value)) == 1 {
      $orders: nth(map-values($value), 1);
    } @else {
      $orders: map-values($value);
    }
  }

  @if $orders {
    $min-order: min($orders...);
    $new-orders: ();

    @if $min-order <= 0 {
      @each $item in $orders {
        $new-orders: append($new-orders, ($item + abs($min-order) + 1));
      }

      $orders: $new-orders;
    }
  }

  @return $orders;
}